# Reporte de Incidencia y Solución: Configuración SSL/HTTPS en Docker
**Fecha:** 17 de Diciembre de 2025
**Contexto:** Despliegue de SmartDineBackend en Azure con Docker Compose y SSL (Let's Encrypt).

## 1. Descripción del Problema
La aplicación Spring Boot fallaba al arrancar o no aceptaba conexiones HTTPS en el puerto 8443.
- **Errores observados:**
  - `java.security.UnrecoverableKeyException: Get Key failed: Given final block not properly padded` (Contraseña incorrecta).
  - `curl: (35) OpenSSL SSL_connect: SSL_ERROR_SYSCALL` (Conexión cortada).
  - La aplicación arrancaba en el puerto `8080 (http)` ignorando la configuración SSL.

## 2. Causas Identificadas
1. **Inconsistencia de Contraseñas:** El archivo `keystore.p12` se generó con una contraseña diferente a la configurada en el entorno, o estaba corrupto.
2. **Permisos de Archivo:** El contenedor Docker no tenía permisos para leer los certificados directamente desde `/etc/letsencrypt/live/` debido a restricciones de permisos en el host.
3. **Nombres de Variables Incorrectos:** Spring Boot espera variables con el prefijo `SERVER_` (ej. `SERVER_SSL_KEY_STORE_PASSWORD`), pero en el `.env` se usaban nombres genéricos (`SSL_KEY_STORE_PASSWORD`), por lo que la configuración era ignorada.
4. **Puerto por Defecto:** No se especificaba `SERVER_PORT=8443` en el `.env`, por lo que Spring Boot arrancaba en el 8080 por defecto, haciendo imposible la conexión SSL en el puerto mapeado 8443.

## 3. Solución Implementada

### Paso 1: Regenerar el Keystore correctamente
Se regeneró el archivo PKCS12 asegurando que la contraseña coincida exactamente con la del `.env`.

```bash
# Ejemplo de comando usado
sudo openssl pkcs12 -export \
  -in /etc/letsencrypt/live/midominio.com/fullchain.pem \
  -inkey /etc/letsencrypt/live/midominio.com/privkey.pem \
  -out ./certs/keystore.p12 \
  -name springboot \
  -passout pass:mV00R152
```

### Paso 2: Ubicación y Permisos
Se movió el certificado a una carpeta local `./certs/` en el proyecto para evitar problemas de permisos con `/etc/letsencrypt/`.

```yaml
# compose.yaml
volumes:
  - ./certs/keystore.p12:/app/certs/keystore.p12:ro
```

### Paso 3: Corrección de Variables de Entorno (.env)
Se renombraron las variables para cumplir con la convención de Spring Boot (`SERVER_...`).

**Antes (Incorrecto):**
```dotenv
APP_HTTPS_PORT=8443
SSL_KEY_STORE_PASSWORD=mV00R152
```

**Ahora (Correcto):**
```dotenv
SERVER_PORT=8443
SERVER_SSL_ENABLED=true
SERVER_SSL_KEY_STORE=/app/certs/keystore.p12
SERVER_SSL_KEY_STORE_PASSWORD=mV00R152
SERVER_SSL_KEY_STORE_TYPE=PKCS12
SERVER_SSL_KEY_ALIAS=springboot
```

## 4. Comandos de Verificación
Para diagnosticar problemas futuros:

**Verificar contraseña y validez del keystore:**
```bash
keytool -list -v -keystore ./certs/keystore.p12 -storepass mV00R152 -storetype PKCS12
```

**Verificar logs de arranque:**
```bash
docker compose logs springboot-app | grep "Tomcat started on port"
# Debe decir: Tomcat started on port(s): 8443 (https)
```

**Probar conexión:**
```bash
curl -k https://localhost:8443/actuator/health
```
